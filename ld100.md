## 二分

### ld74.搜索二维矩阵

- **思路1**：先按列查找，找到最后一个小于等于target的位置，即右边界，判断这个位置是不是target，如果是，则返回True，否则。按行查找，找到第一个大于等于target的位置，即左边界，判断这个位置是不是target

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        # 思路：先按列二分，找到最后一个小于等于target的位置，如果不等于target，则继续行二分
        # 之后按行二分，找到第一个大于等于target的位置

        l, r = 0, len(matrix) - 1

        while l < r:
            mid = (l + r + 1) // 2

            if matrix[mid][0] <= target:
                l = mid
            else:
                r = mid - 1

        if matrix[l][0] == target:
            return True
        else:
            # 继续按行二分
            L, R = 0, len(matrix[l]) - 1
            
            while L < R:
                mid = (L + R) // 2

                if matrix[l][mid] >= target:
                    R = mid
                else:
                    L = mid + 1

            if matrix[l][L] == target:
                return True

        return False
```

- **思路2**：发现整个矩阵展开后为一个升序的数组，那么直接用传统二分查找一遍即可，找左边界
- 位置映射：`i = mid / m`, `j = mid % m`或者直接展开

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        n, m = len(matrix) - 1, len(matrix[0]) - 1

        a = []

        for x in matrix:
            a.extend(x) # extend与append用法区别

        l, r = 0, len(a) - 1
        while l < r:
            mid = (l + r) // 2

            if a[mid] >= target:
                r = mid
            else:
                l = mid + 1

        return a[l] == target
```

### ld34.在排序数组中查找元素的第一个和最后一个位置

- **思路**：分别找左右边界,如果找不到左边界，则直接返回`-1 -1`即可，如果找到了左边界则继续找右边界

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not len(nums):
            return [-1, -1]

        l, r = 0, len(nums) - 1

        while l < r:
            mid = (l + r + 1) // 2

            if nums[mid] <= target:
                l = mid
            else:
                r = mid - 1

        if nums[l] != target:
            return [-1, -1]

        L, R = 0, len(nums) - 1

        while (L < R):
            mid = (L + R) // 2

            if nums[mid] >= target:
                R = mid
            else:
                L = mid + 1

        return [L, l]
```

### ld33.搜索旋转排序数组

- **思路**：先二分出两段区间的边界点，即找到最后一个大于等于`nums[0]`的位置，然后下一个位置就是下一段区间的开始。再比较`target`和两个区间的起始位置，判断在哪个区间做二分
- 这题要小心越界

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l < r:
            mid = (l + r + 1) // 2

            if nums[mid] >= nums[0]:
                l = mid
            else:
                r = mid - 1

        if target >= nums[0]:
            l = 0
        else: # 对于[1] 0这样的样例，不会进入二分，但这里会对l进行+1处理，所以最后用l判断的时候会越界
            l = r + 1
            r = len(nums) - 1
        
        while l < r:
            mid = (l + r) // 2

            if nums[mid] >= target:
                r = mid
            else:
                l = mid + 1

        if nums[r] == target:
            return l
        else:
            return -1
```

### ld153.寻找旋转排序数组中的最小元素

- **思路**：旋转后区间被分为两段，找到区间分界点即可，然后对比两个区间开头元素的大小

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1

        while l < r:
            mid = (l + r + 1) // 2

            if nums[mid] >= nums[0]:
                l = mid
            else:
                r = mid - 1

        if r == len(nums) - 1:
            return nums[0]

        if nums[0] < nums[r + 1]:
            return nums[0]
        else:
            return nums[r + 1]
```

### ld162寻找峰值

- **思路**：先看中点，如果中点呈现上升趋势，即`nums[mid] < nums[mid + 1]`，那么首先中点一定不是峰值，其次，中点的右边要么延续上升趋势，要么波动，如果是延续了上升趋势，则最右边的点是峰值，否则峰值在右边的某个位置，因此右边一定存在峰值。如果中点呈现下降趋势，那么峰值要么是中点，要么在中点左边
- 为什么不需要判断`mid + 1`是否越界：因为如果`mid = len(nums) - 1`，说明`l`和`r`已经相等且为`len(nums) - 1`了
- 不存在单调性的题目不一定不能用二分解决

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1

        while l < r:
            mid = (l + r) // 2
            if nums[mid] < nums[mid + 1]:
                # 往后边找，一定是存在峰值的
                l = mid + 1
            else:
                r = mid

        return l
```

## 前缀和与差分

### acwing.795前缀合

- 前缀和的作用是在O(1)的时间复杂度求出某个区间的总和
- `s[i] = a[1] + a[2] + .... + a[i]`,求`s[i]`的方法是遍历一遍`s[i] = a[i] + s[i - 1]`
- 求区间`[l, r]`的所有数的和，`s[r] - s[l - 1]`，一次运算求出任意区间的数之和

```python
n, m = map(int, input().strip().split())
    
a = list(map(int, input().strip().split()))
a = [0] + a
    
s = [0 for _ in range(n + 1)]
    
for i in range(1, n + 1):
    s[i] = s[i - 1] + a[i]
        
while m:
    m -= 1
        
    l, r = map(int, input().strip().split())
        
    print(s[r] - s[l - 1])
```

### acwing796.子矩阵的和

- 二维前缀和:画图理解即可

```python
n, m, q = map(int, input().strip().split())

a = [[0] * (m + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
    a[i][1:] = list(map(int, input().strip().split()))
    

s = [[0] * (m + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
    for j in range(1, m + 1):
        s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]
    

while q:
    q -= 1
    
    x1, y1, x2, y2 = map(int, input().strip().split())
    
    res = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]
    print(res)
```

### acwing797.差分

- 差分是构建一个数组`b`，使得`ai = b1 + b2 + .... + bi`,即构造出来的数组的前缀和是原数组
- `b1 = a1, b2 = a2 - a1, b3 = a3 - a2`
- 其作用`O(1)`时间复杂度对给定`[l, r]`区间的所有数加上`c`
- `b[l] += c`, `b[r + 1] -= c`，再对数组b求一次前缀和得到`a`，完成区间修改

```python
a = [0 for _ in range(100010)]
b = [0 for _ in range(100010)]

def insert(l, r, c):
    b[l] += c
    b[r + 1] -= c

n, m = map(int, input().strip().split())

a[1:] = list(map(int, input().strip().split()))

# print(a)

for i in range(1, n + 1):
    insert(i, i, a[i])  # 这里是对b进行操作，这样操作之后b数组自然而然就是a的差分数组了

while m:
    m -= 1
    
    l, r, c = map(int, input().strip().split())
    insert(l, r, c)

for i in range(1, n + 1):
    a[i] = a[i - 1] + b[i]
    print(a[i], end=' ')
```

## 双指针算法

### acwing799.最长连续不重复子序列

```python
a = [0 for _ in range(100010)]
cnt = [0 for _ in range(100010)]

n = int(input())
a[1:] = list(map(int, input().strip().split()))

res = 0
j = 1
for i in range(1, n + 1):
    cnt[a[i]] += 1
    while cnt[a[i]] > 1:
        cnt[a[j]] -= 1
        j += 1
        
    res = max(res, i - j + 1)
    
print(res)
```
### ld283.移动零

- **思路**:双指针算法，其中一个指针用来枚举填入有效数字的位置，另一个指针用来枚举数组，将所有有效数字填入完成后，再将后面的填入0即可

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        j = 0 # 枚举填入的位置

        # 枚举数组
        for i in range(n):
            if nums[i] != 0:
                nums[j] = nums[i]
                j += 1

        for i in range(j, n):
            nums[i] = 0
```

### acwing800.数组元素的目标和

- **思路**：数组`a`往后枚举，数组`b`往前枚举，如果相加大于目标值，则`b`往前走一步，如果相加小于目标值,则`a`往后走一步，双指针算法
- 时间复杂度O(N)

```python
a = [0 for _ in range(100010)]
b = [0 for _ in range(100010)]

n, m, x = map(int, input().strip().split())
a = list(map(int, input().strip().split()))
b = list(map(int, input().strip().split()))

i = 0
j = m - 1
flag = 1
while flag:
    if a[i] + b[j] == x:
        flag = 0
    
    if a[i] + b[j] > x:
        j -= 1
    
    if a[i] + b[j] < x:
        i += 1
        
print(i, j)
```

### ld11.盛最多水的容器

- **思考方式**：先想暴力做法，两层循环搞定。再想如何优化
- 考虑到容器的容积和最矮的挡板有关，因此考虑从两头枚举，这样宽度是只会变小，只需要考虑高度。如果一边比另一边矮，则矮的一侧会向后走，因为高的那一侧不管怎么走，容积永远不会超过当前了

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        n = len(height) - 1
        i = 0
        j = n
        width = n
        res = 0
        while i != j:
            k = min(height[i], height[j])
            res = max(res, k * width)
            if height[i] < height[j]:
                i += 1
            else:
                j -= 1
            width -= 1
        
        return res

```

### acwing2816.判断子序列

- 双指针

```python
a = [0 for _ in range(100010)]
b = [0 for _ in range(100010)]

n, m = map(int, input().strip().split())

a = list(map(int, input().strip().split()))
b = list(map(int, input().strip().split()))

i = 0
flag = 0
for j in range(m):
    if b[j] == a[i]:
        i += 1
        if i == n:
            flag = 1
            break
        
if flag:
    print("Yes")
else:
    print("No")
```

### ld27.移除元素

- 思路：双指针，一个指针指向填充的位置，一个指针枚举数组

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        n = len(nums)
        i = 0
        for j in range(n):
            if nums[j] != val:
                nums[i] = nums[j]
                i += 1

        return i
```

### ld15.三数之和

- 先考虑暴力做法，然后想怎么优化，**如果出现有序，可以考虑双指针**
- **Python集合的用法**

```python
# 集合满足不存在重复元素
res = set() #定义一个空集合
res = {1, 2, 4, 1, 2, 3} # 可以用大括号创建一个集合，输出这个集合为{1, 2, 4}

# add方法
thisset = set(("Google", "Runoob", "Taobao"))
thisset.add("Facebook")
print(thisset) # {'Taobao', 'Facebook', 'Google', 'Runoob'}


# remove方法
thisset = set(("Google", "Runoob", "Taobao"))
thisset.remove("Taobao")
print(thisset) # {'Google', 'Runoob'}
```

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)

        nums.sort()

        res = set()
        
        for i in range(n):
            # 为了排除重新的三元组，i移动后如果nums[i]没有改变，则需要继续移动
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            j = i + 1
            k = n - 1
            while j < k:
                sum = nums[i] + nums[j] + nums[k]
                # 排完序后如果sum>0说明只能k往前移动,i和j往后移动都会使得sum继续变大
                if sum > 0:
                    k -= 1
                elif sum < 0:
                    j += 1
                else:
                    res.add((nums[i], nums[j], nums[k]))
                    k -= 1
                    j += 1
        return list(res)
```
