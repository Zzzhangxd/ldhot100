## 二分

### ld74.搜索二维矩阵

- **思路1**：先按列查找，找到最后一个小于等于target的位置，即右边界，判断这个位置是不是target，如果是，则返回True，否则。按行查找，找到第一个大于等于target的位置，即左边界，判断这个位置是不是target

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        # 思路：先按列二分，找到最后一个小于等于target的位置，如果不等于target，则继续行二分
        # 之后按行二分，找到第一个大于等于target的位置

        l, r = 0, len(matrix) - 1

        while l < r:
            mid = (l + r + 1) // 2

            if matrix[mid][0] <= target:
                l = mid
            else:
                r = mid - 1

        if matrix[l][0] == target:
            return True
        else:
            # 继续按行二分
            L, R = 0, len(matrix[l]) - 1
            
            while L < R:
                mid = (L + R) // 2

                if matrix[l][mid] >= target:
                    R = mid
                else:
                    L = mid + 1

            if matrix[l][L] == target:
                return True

        return False
```

- **思路2**：发现整个矩阵展开后为一个升序的数组，那么直接用传统二分查找一遍即可，找左边界
- 位置映射：`i = mid / m`, `j = mid % m`或者直接展开

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        n, m = len(matrix) - 1, len(matrix[0]) - 1

        a = []

        for x in matrix:
            a.extend(x) # extend与append用法区别

        l, r = 0, len(a) - 1
        while l < r:
            mid = (l + r) // 2

            if a[mid] >= target:
                r = mid
            else:
                l = mid + 1

        return a[l] == target
```

### ld34.在排序数组中查找元素的第一个和最后一个位置

- **思路**：分别找左右边界,如果找不到左边界，则直接返回`-1 -1`即可，如果找到了左边界则继续找右边界

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not len(nums):
            return [-1, -1]

        l, r = 0, len(nums) - 1

        while l < r:
            mid = (l + r + 1) // 2

            if nums[mid] <= target:
                l = mid
            else:
                r = mid - 1

        if nums[l] != target:
            return [-1, -1]

        L, R = 0, len(nums) - 1

        while (L < R):
            mid = (L + R) // 2

            if nums[mid] >= target:
                R = mid
            else:
                L = mid + 1

        return [L, l]
```

### ld33.搜索旋转排序数组

- **思路**：先二分出两段区间的边界点，即找到最后一个大于等于`nums[0]`的位置，然后下一个位置就是下一段区间的开始。再比较`target`和两个区间的起始位置，判断在哪个区间做二分
- 这题要小心越界

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l < r:
            mid = (l + r + 1) // 2

            if nums[mid] >= nums[0]:
                l = mid
            else:
                r = mid - 1

        if target >= nums[0]:
            l = 0
        else: # 对于[1] 0这样的样例，不会进入二分，但这里会对l进行+1处理，所以最后用l判断的时候会越界
            l = r + 1
            r = len(nums) - 1
        
        while l < r:
            mid = (l + r) // 2

            if nums[mid] >= target:
                r = mid
            else:
                l = mid + 1

        if nums[r] == target:
            return l
        else:
            return -1
```

### ld153.寻找旋转排序数组中的最小元素

- **思路**：旋转后区间被分为两段，找到区间分界点即可，然后对比两个区间开头元素的大小

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1

        while l < r:
            mid = (l + r + 1) // 2

            if nums[mid] >= nums[0]:
                l = mid
            else:
                r = mid - 1

        if r == len(nums) - 1:
            return nums[0]

        if nums[0] < nums[r + 1]:
            return nums[0]
        else:
            return nums[r + 1]
```

### ld162寻找峰值

- **思路**：先看中点，如果中点呈现上升趋势，即`nums[mid] < nums[mid + 1]`，那么首先中点一定不是峰值，其次，中点的右边要么延续上升趋势，要么波动，如果是延续了上升趋势，则最右边的点是峰值，否则峰值在右边的某个位置，因此右边一定存在峰值。如果中点呈现下降趋势，那么峰值要么是中点，要么在中点左边
- 为什么不需要判断`mid + 1`是否越界：因为如果`mid = len(nums) - 1`，说明`l`和`r`已经相等且为`len(nums) - 1`了
- 不存在单调性的题目不一定不能用二分解决

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1

        while l < r:
            mid = (l + r) // 2
            if nums[mid] < nums[mid + 1]:
                # 往后边找，一定是存在峰值的
                l = mid + 1
            else:
                r = mid

        return l
```

## 前缀和与差分

### acwing.795前缀合

- 前缀和的作用是在O(1)的时间复杂度求出某个区间的总和
- `s[i] = a[1] + a[2] + .... + a[i]`,求`s[i]`的方法是遍历一遍`s[i] = a[i] + s[i - 1]`
- 求区间`[l, r]`的所有数的和，`s[r] - s[l - 1]`，一次运算求出任意区间的数之和

```python
n, m = map(int, input().strip().split())
    
a = list(map(int, input().strip().split()))
a = [0] + a
    
s = [0 for _ in range(n + 1)]
    
for i in range(1, n + 1):
    s[i] = s[i - 1] + a[i]
        
while m:
    m -= 1
        
    l, r = map(int, input().strip().split())
        
    print(s[r] - s[l - 1])
```

### acwing796.子矩阵的和

- 二维前缀和:画图理解即可

```python
n, m, q = map(int, input().strip().split())

a = [[0] * (m + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
    a[i][1:] = list(map(int, input().strip().split()))
    

s = [[0] * (m + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
    for j in range(1, m + 1):
        s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]
    

while q:
    q -= 1
    
    x1, y1, x2, y2 = map(int, input().strip().split())
    
    res = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]
    print(res)
```

### acwing797.差分

- 差分是构建一个数组`b`，使得`ai = b1 + b2 + .... + bi`,即构造出来的数组的前缀和是原数组
- `b1 = a1, b2 = a2 - a1, b3 = a3 - a2`
- 其作用`O(1)`时间复杂度对给定`[l, r]`区间的所有数加上`c`
- `b[l] += c`, `b[r + 1] -= c`，再对数组b求一次前缀和得到`a`，完成区间修改

```python
a = [0 for _ in range(100010)]
b = [0 for _ in range(100010)]

def insert(l, r, c):
    b[l] += c
    b[r + 1] -= c

n, m = map(int, input().strip().split())

a[1:] = list(map(int, input().strip().split()))

# print(a)

for i in range(1, n + 1):
    insert(i, i, a[i])  # 这里是对b进行操作，这样操作之后b数组自然而然就是a的差分数组了

while m:
    m -= 1
    
    l, r, c = map(int, input().strip().split())
    insert(l, r, c)

for i in range(1, n + 1):
    a[i] = a[i - 1] + b[i]
    print(a[i], end=' ')
```

## 双指针算法

### acwing799.最长连续不重复子序列

```python
a = [0 for _ in range(100010)]
cnt = [0 for _ in range(100010)]

n = int(input())
a[1:] = list(map(int, input().strip().split()))

res = 0
j = 1
for i in range(1, n + 1):
    cnt[a[i]] += 1
    while cnt[a[i]] > 1:
        cnt[a[j]] -= 1
        j += 1
        
    res = max(res, i - j + 1)
    
print(res)
```
